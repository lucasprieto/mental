---
phase: 18-auth0-integration
plan: 01
type: execute
depends_on: []
files_modified: [packages/db/src/schema-pg.ts, packages/api/src/middleware/api-key.ts, packages/api/src/routes/api-keys.ts, packages/api/src/index.ts]
---

<objective>
Add users and API keys tables to database, create API key generation and validation infrastructure.

Purpose: Foundation for multi-user support - users table links to Auth0, api_keys table enables MCP server authentication.
Output: Database schema with users/api_keys, API key middleware, and key management routes.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-auth0-integration/18-RESEARCH.md

@packages/db/src/schema-pg.ts
@packages/api/src/index.ts

**Tech stack available:** Hono, Drizzle ORM, PostgreSQL (Neon)
**Established patterns:** Drizzle schema definitions, Hono route structure

**From RESEARCH.md:**
- Users table: id (Auth0 sub), email, name, timestamps
- API keys table: id, userId, keyHash (SHA-256), name, lastUsedAt, timestamps
- Hash API keys with SHA-256 before storage (not bcrypt - overkill for random keys)
- Use crypto.randomBytes for key generation, show key only once at creation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add users and api_keys tables to database schema</name>
  <files>packages/db/src/schema-pg.ts, packages/db/src/index.ts</files>
  <action>
Add two new tables to schema-pg.ts:

1. `users` table:
   - id: text primary key (will store Auth0 `sub` claim)
   - email: text not null
   - name: text nullable
   - createdAt: timestamp defaultNow
   - updatedAt: timestamp defaultNow

2. `api_keys` table:
   - id: text primary key (use cuid)
   - userId: text not null (references users.id)
   - keyHash: text not null unique (SHA-256 hash of raw key)
   - name: text not null default 'Default Key'
   - lastUsedAt: timestamp nullable
   - createdAt: timestamp defaultNow

Export types for both tables. Update index.ts to export new tables.

Do NOT add foreign key constraint yet (will add after initial migration).
  </action>
  <verify>pnpm --filter @mental/db build succeeds, types exported correctly</verify>
  <done>users and api_keys tables defined with proper types, exported from package</done>
</task>

<task type="auto">
  <name>Task 2: Create API key validation middleware</name>
  <files>packages/api/src/middleware/api-key.ts</files>
  <action>
Create middleware directory and api-key.ts:

```typescript
import { createMiddleware } from "hono/factory";
import { createHash } from "crypto";
import { eq } from "drizzle-orm";
import { getDb } from "../db.js";
import { apiKeys } from "@mental/db";

export const apiKeyAuth = createMiddleware(async (c, next) => {
  const key = c.req.header("X-API-Key");

  if (!key) {
    return c.json({ error: "X-API-Key header required" }, 401);
  }

  const keyHash = createHash("sha256").update(key).digest("hex");
  const db = getDb();

  const [record] = await db
    .select()
    .from(apiKeys)
    .where(eq(apiKeys.keyHash, keyHash))
    .limit(1);

  if (!record) {
    return c.json({ error: "Invalid API key" }, 401);
  }

  // Update last used (fire and forget)
  db.update(apiKeys)
    .set({ lastUsedAt: new Date() })
    .where(eq(apiKeys.id, record.id))
    .execute();

  c.set("userId", record.userId);
  c.set("apiKeyId", record.id);

  await next();
});
```

This middleware validates X-API-Key header against hashed keys in database.
  </action>
  <verify>TypeScript compiles, middleware exports correctly</verify>
  <done>apiKeyAuth middleware created, validates API keys by hashing and comparing</done>
</task>

<task type="auto">
  <name>Task 3: Create API key management routes</name>
  <files>packages/api/src/routes/api-keys.ts, packages/api/src/index.ts</files>
  <action>
Create api-keys.ts route with endpoints for key management:

1. POST /api-keys - Create new API key
   - Accepts: { userId, name? }
   - Generates random key with prefix: `mental_${randomBytes(32).toString("hex")}`
   - Hashes with SHA-256 for storage
   - Returns: { id, key, name, createdAt } - raw key shown ONLY HERE
   - Note: In production, userId comes from JWT. For now, accept it in body.

2. GET /api-keys?userId=xxx - List user's API keys
   - Returns: Array of { id, name, lastUsedAt, createdAt } (NO key/hash)

3. DELETE /api-keys/:id - Delete an API key
   - Soft delete or hard delete (hard delete is simpler)
   - Returns: { success: true }

Add cuid2 package for ID generation: pnpm --filter @mental/api add @paralleldrive/cuid2

Mount route in index.ts: app.route("/api-keys", apiKeysRoute)

Use zod for validation (already in project).
  </action>
  <verify>curl POST /api-keys creates key and returns raw key, GET lists keys without hash, DELETE removes key</verify>
  <done>API key CRUD routes working, key only shown at creation time</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm build` succeeds for db and api packages
- [ ] New tables defined in schema with correct types
- [ ] API key middleware validates keys correctly
- [ ] POST /api-keys returns raw key only once
- [ ] GET /api-keys returns key metadata (no hash/raw key)
- [ ] DELETE /api-keys/:id removes the key
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Database schema ready for migration (run in Phase 19 during deployment)
- API key infrastructure ready for MCP server integration
</success_criteria>

<output>
After completion, create `.planning/phases/18-auth0-integration/18-01-SUMMARY.md`
</output>
