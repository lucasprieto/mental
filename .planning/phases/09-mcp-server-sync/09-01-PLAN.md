---
phase: 09-mcp-server-sync
plan: 01
type: execute
depends_on: []
files_modified:
  - packages/mcp-server/package.json
  - packages/mcp-server/src/index.ts
  - packages/mcp-server/src/api.ts
  - packages/mcp-server/src/db.ts
---

<objective>
Update MCP server to use remote API instead of local SQLite database.

Purpose: Enable multi-computer access by routing all data operations through the hosted API.
Output: MCP server that calls remote API for all thought capture and retrieval operations.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase research (just completed):
@.planning/phases/09-mcp-server-sync/09-RESEARCH.md

# Prior phase summaries (API routes and data sync):
@.planning/phases/07-backend-setup/07-02-SUMMARY.md
@.planning/phases/08-data-sync/08-02-SUMMARY.md

# Current MCP server implementation:
@packages/mcp-server/src/index.ts
@packages/mcp-server/src/db.ts
@packages/mcp-server/package.json

# API types for RPC client:
@packages/api/src/index.ts
@packages/api/src/routes/items.ts
@packages/api/src/routes/sessions.ts

**Tech stack available:** hono (for hc client), @mental/api (for AppType)
**Established patterns:** Hono RPC client with hc<AppType>(), lazy initialization
**Constraining decisions:**
- Phase 7: API exports AppType for RPC client usage
- Phase 7: All drizzle imports from @mental/db
- Phase 8: Data migrated to Neon, SQLite no longer primary
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Hono client and create API module</name>
  <files>packages/mcp-server/package.json, packages/mcp-server/src/api.ts</files>
  <action>
1. Add `hono` dependency to mcp-server package.json (version ^4.6.0 to match API package)
2. Create `src/api.ts` with:
   - Import `hc` from "hono/client"
   - Import `AppType` from "@mental/api" (type-only import)
   - Export `getApiClient()` function that returns `hc<AppType>(API_URL)`
   - Get API_URL from `process.env.MENTAL_API_URL` with fallback to "http://localhost:3000"
   - Log API URL to stderr on first call for debugging

Pattern from research:
```typescript
import { hc } from "hono/client";
import type { AppType } from "@mental/api";

const API_URL = process.env.MENTAL_API_URL || "http://localhost:3000";
let client: ReturnType<typeof hc<AppType>> | null = null;

export function getApiClient() {
  if (!client) {
    console.error(`[mental-mcp] Connecting to API: ${API_URL}`);
    client = hc<AppType>(API_URL);
  }
  return client;
}
```
  </action>
  <verify>pnpm install succeeds, TypeScript compiles without errors: cd packages/mcp-server && pnpm build</verify>
  <done>hono added to dependencies, api.ts exports typed getApiClient() function, builds without errors</done>
</task>

<task type="auto">
  <name>Task 2: Convert all tools to use API calls</name>
  <files>packages/mcp-server/src/index.ts</files>
  <action>
Update each tool handler to use API instead of direct database access. Keep theme extraction local (runs before API call).

**Import changes:**
- Remove: `import { getDatabase } from "./db.js"`
- Remove: `import { mentalItems, desc, eq } from "@mental/db"`
- Add: `import { getApiClient } from "./api.js"`

**Tool conversions:**

1. **capture_thought** (line ~60):
   - Keep local theme extraction
   - Replace db.insert() with:
   ```typescript
   const api = getApiClient();
   const res = await api.items.$post({
     json: { title, content, tags: tags || [], theme, sessionId: currentSessionId }
   });
   if (!res.ok) {
     console.error("[mental-mcp] API error:", res.status);
     return { content: [{ type: "text", text: `Error capturing thought: ${res.status}` }] };
   }
   const item = await res.json();
   ```
   - Use `item.id` in response (API generates ID)

2. **list_thoughts** (line ~105):
   - Replace db.select() with:
   ```typescript
   const api = getApiClient();
   const res = await api.items.$get({
     query: { status: status || "all", limit: maxItems }
   });
   if (!res.ok) throw new Error(`API error: ${res.status}`);
   const items = await res.json();
   ```

3. **get_thought** (line ~153):
   - Replace db.select().where() with:
   ```typescript
   const api = getApiClient();
   const res = await api.items[":id"].$get({ param: { id } });
   if (res.status === 404) {
     return { content: [{ type: "text", text: `Thought not found: ${id}` }] };
   }
   const item = await res.json();
   ```

4. **resolve_thought** (line ~205):
   - First GET to check existence and current status
   - If not found or already resolved, return appropriate message
   - Replace db.update() with:
   ```typescript
   const api = getApiClient();
   const res = await api.items[":id"].$put({
     param: { id },
     json: { status: "resolved", resolution }
   });
   ```

5. **reopen_thought** (line ~266):
   - First GET to check existence and current status
   - Replace db.update() with:
   ```typescript
   const api = getApiClient();
   const res = await api.items[":id"].$put({
     param: { id },
     json: { status: "open" }
   });
   ```

6. **start_session** (line ~324):
   - Replace local ID generation with API call:
   ```typescript
   const api = getApiClient();
   const res = await api.sessions.start.$post({ json: { name } });
   const session = await res.json();
   currentSessionId = session.sessionId;
   sessionStartTime = new Date(session.startedAt);
   ```

7. **end_session** (line ~354):
   - Replace db.select() with:
   ```typescript
   const api = getApiClient();
   const res = await api.sessions.end.$post();
   if (!res.ok) {
     return { content: [{ type: "text", text: "No active session" }] };
   }
   const summary = await res.json();
   currentSessionId = null;
   sessionStartTime = null;
   ```
   - Use `summary.itemCount` instead of filtering items locally

**Keep unchanged:**
- `ping` tool (no DB access)
- `extractTheme()` function (local preprocessing)
- Session tracking variables (currentSessionId, sessionStartTime) - still needed locally

**Error handling pattern:** Check `res.ok`, return user-friendly error message with status code, log full error to stderr.
  </action>
  <verify>
1. Build: cd packages/mcp-server && pnpm build
2. Test with MCP inspector (requires API running):
   - Start API: cd packages/api && DATABASE_URL="..." pnpm dev
   - Test: MENTAL_API_URL=http://localhost:3000 npx @modelcontextprotocol/inspector node packages/mcp-server/dist/index.js
   - Call ping tool (should work)
   - Call list_thoughts tool (should return items from Neon)
  </verify>
  <done>All 8 tools converted to API calls, builds without TypeScript errors, tools return data from remote API</done>
</task>

<task type="auto">
  <name>Task 3: Clean up dependencies</name>
  <files>packages/mcp-server/src/db.ts, packages/mcp-server/package.json</files>
  <action>
1. Delete `packages/mcp-server/src/db.ts` (no longer needed)
2. Update package.json dependencies:
   - Remove: `"@mental/db": "workspace:*"` (no longer direct DB access)
   - Remove: `"drizzle-orm": "^0.29.5"` (no longer used)
   - Keep: `"@mental/shared": "workspace:*"` (if types are used - check first)
   - Keep: `"@modelcontextprotocol/sdk"`, `"@paralleldrive/cuid2"`, `"zod"`, `"hono"`
3. Add `"@mental/api": "workspace:*"` for type imports
4. Run `pnpm install` to update lockfile
5. Verify build still works: `cd packages/mcp-server && pnpm build`

**Check @mental/shared usage:** grep for "@mental/shared" in index.ts. If not used, remove from dependencies.
  </action>
  <verify>
1. db.ts deleted: `ls packages/mcp-server/src/` shows only index.ts and api.ts
2. Dependencies updated: `cat packages/mcp-server/package.json | grep -E "@mental|drizzle"`
3. Build passes: `cd packages/mcp-server && pnpm build`
4. No TypeScript errors about missing imports
  </verify>
  <done>db.ts removed, unused dependencies removed, @mental/api added, package builds cleanly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm install` succeeds at root
- [ ] `cd packages/mcp-server && pnpm build` succeeds without errors
- [ ] db.ts file no longer exists
- [ ] MCP server no longer imports from @mental/db
- [ ] API client module exists with typed getApiClient()
- [ ] With API running, MCP tools return data from remote database
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- MCP server fully decoupled from local SQLite
- Tools work via remote API (tested with MCP inspector)
</success_criteria>

<output>
After completion, create `.planning/phases/09-mcp-server-sync/09-01-SUMMARY.md`:

# Phase 9 Plan 01: MCP Server Sync Summary

**[Substantive one-liner - what shipped]**

## Performance

- **Duration:** X min
- **Started:** timestamp
- **Completed:** timestamp
- **Tasks:** 3
- **Files modified:** N

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Task Commits

1. **Task 1: ...** - `hash` (type)
2. **Task 2: ...** - `hash` (type)
3. **Task 3: ...** - `hash` (type)

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions or "None"]

## Deviations from Plan

[If any auto-fixed issues, document per deviation format]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 9 complete, ready for Phase 10 (Webapp Sync)

---
*Phase: 09-mcp-server-sync*
*Completed: date*
</output>
