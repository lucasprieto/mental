---
phase: 06-webapp-features
plan: 02
type: execute
depends_on: []
files_modified: [packages/webapp/src/components/CaptureModal.tsx, packages/webapp/src/app/page.tsx, packages/webapp/src/app/item/[id]/page.tsx, packages/webapp/src/components/EditItemForm.tsx, packages/webapp/src/app/api/items/route.ts, packages/webapp/src/app/api/items/[id]/route.ts]
---

<objective>
Add manual entry via quick capture modal and item editing capability.

Purpose: Complete the webapp as a standalone companion â€” users can capture and edit thoughts directly without MCP.
Output: Capture modal on dashboard + edit form on item detail page + API routes for CRUD operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-webapp-features/06-CONTEXT.md
@packages/webapp/src/app/page.tsx
@packages/webapp/src/app/item/[id]/page.tsx
@packages/db/src/schema.ts

**Established patterns:**
- Server components with force-dynamic
- cuid2 for ID generation (from @mental/db or use createId from @paralleldrive/cuid2)
- Tags as JSON string array
- Timestamps as integers (Date objects via Drizzle mode)

**Key decisions:**
- [03-01]: cuid2 for ID generation
- [03-01]: Theme extraction uses pattern matching with fallback
- [05-01]: force-dynamic for database pages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API routes for items</name>
  <files>packages/webapp/src/app/api/items/route.ts, packages/webapp/src/app/api/items/[id]/route.ts</files>
  <action>Create two API route files:

  **POST /api/items (route.ts):**
  - Accept JSON body: { title, content, tags?: string[], theme?: string }
  - Validate: title and content required, non-empty
  - Generate ID with createId() from @paralleldrive/cuid2
  - Insert into mentalItems with status="open", createdAt/updatedAt=now
  - Return created item as JSON

  **PUT /api/items/[id] (route.ts):**
  - Accept JSON body: { title?, content?, tags?, theme?, status?, resolution? }
  - Find item by ID, return 404 if not found
  - Update only provided fields, always update updatedAt
  - If status changes to "resolved", set resolvedAt
  - If status changes to "open", keep resolvedAt (history tracking per 04-01 decision)
  - Return updated item as JSON

  Use NextResponse for responses. Handle errors with appropriate status codes (400 for validation, 404 for not found, 500 for DB errors).</action>
  <verify>curl -X POST localhost:3001/api/items -H "Content-Type: application/json" -d '{"title":"Test","content":"Test content"}' returns 200 with created item</verify>
  <done>POST creates items, PUT updates items, proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create CaptureModal component</name>
  <files>packages/webapp/src/components/CaptureModal.tsx</files>
  <action>Create a client component ("use client") for quick capture:
  - Modal overlay with centered white box
  - Form fields: title (input), content (textarea), tags (comma-separated input)
  - Submit button and Cancel button
  - On submit: POST to /api/items, on success refresh router and close modal
  - Use useRouter() for router.refresh() after successful save
  - Show loading state during submit
  - Close on Escape key or clicking overlay

  Props: isOpen, onClose

  Keep it simple - no theme field (auto-extraction is MCP's job, webapp is explicit entry).
  Style consistent with existing cards (bg-white, rounded-lg, shadow-lg for modal).</action>
  <verify>Component renders modal with form, TypeScript compiles</verify>
  <done>CaptureModal component with title/content/tags form, posts to API, closes on success</done>
</task>

<task type="auto">
  <name>Task 3: Add capture button to dashboard and integrate modal</name>
  <files>packages/webapp/src/app/page.tsx</files>
  <action>Update dashboard to include capture functionality:
  1. Import and render CaptureModal (need "use client" wrapper component since page is server component)
  2. Create a new client component DashboardActions that:
     - Contains the "New Thought" button (fixed position bottom-right or in header)
     - Manages modal open/close state
     - Renders CaptureModal
  3. Import DashboardActions into the server page and render it

  Button style: Floating action button (bottom-right) or prominent button in header area. Blue background, white text, + icon.</action>
  <verify>npm run dev, see "New Thought" button, click opens modal, submit creates item, list refreshes</verify>
  <done>Dashboard has capture button, modal opens, creating item works and refreshes list</done>
</task>

<task type="auto">
  <name>Task 4: Create EditItemForm component</name>
  <files>packages/webapp/src/components/EditItemForm.tsx</files>
  <action>Create a client component ("use client") for editing items:
  - Form with: title (input), content (textarea), tags (comma-separated), status (select: open/resolved), resolution (textarea, only if resolved)
  - Pre-populate with existing item values
  - On submit: PUT to /api/items/[id]
  - On success: router.refresh() to update page
  - Cancel button to discard changes (reset to original values)
  - Show loading state during submit

  Props: item (the full item object to edit)

  Style as a card matching existing design.</action>
  <verify>Component renders with pre-filled form, TypeScript compiles</verify>
  <done>EditItemForm component edits items via PUT API, refreshes on success</done>
</task>

<task type="auto">
  <name>Task 5: Add edit capability to item detail page</name>
  <files>packages/webapp/src/app/item/[id]/page.tsx</files>
  <action>Update item detail page to support editing:
  1. Add "Edit" button below the content section
  2. Create a client wrapper component that:
     - Toggles between view mode and edit mode
     - In view mode: shows existing content + Edit button
     - In edit mode: shows EditItemForm
  3. Pass the item to the client wrapper

  Structure: Server component fetches item, passes to client wrapper which handles view/edit toggle.

  Keep the read-only display as default, Edit button reveals the form.</action>
  <verify>npm run dev, navigate to item detail, click Edit, form appears with values, save updates item</verify>
  <done>Item detail page has Edit button, editing works, changes persist and display updates</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] POST /api/items creates new items
- [ ] PUT /api/items/[id] updates existing items
- [ ] CaptureModal opens from dashboard button
- [ ] Creating item via modal works and list refreshes
- [ ] EditItemForm pre-populates with item data
- [ ] Editing item saves changes and page refreshes
- [ ] Status change to resolved sets resolvedAt
- [ ] No TypeScript errors
- [ ] npm run build succeeds
</verification>

<success_criteria>
- All tasks completed
- Manual capture via modal works end-to-end
- Item editing works end-to-end
- Phase 6 complete - webapp fully functional
</success_criteria>

<output>
After completion, create `.planning/phases/06-webapp-features/06-02-SUMMARY.md`
</output>
