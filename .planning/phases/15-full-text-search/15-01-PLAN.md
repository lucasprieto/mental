---
phase: 15-full-text-search
plan: 01
type: execute
depends_on: []
files_modified: [packages/db/src/schema-pg.ts, packages/db/src/index.ts, packages/api/src/routes/items.ts]
---

<objective>
Add full-text search schema and API endpoint.

Purpose: Enable searching across thought titles and content with relevance ranking.
Output: Generated tsvector column with GIN index, search API endpoint returning ranked results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-full-text-search/15-RESEARCH.md

**Key source files:**
@packages/db/src/schema-pg.ts
@packages/db/src/index.ts
@packages/api/src/routes/items.ts

**From RESEARCH.md:**
- Use generated tsvector column (auto-maintained)
- Weight title (A) higher than content (B)
- Use GIN index for fast lookups
- Use plainto_tsquery for user input (handles plain text)
- Use ts_rank for relevance ordering

**Established patterns:**
- Drizzle ORM with pgTable for Postgres schema
- Hono with zValidator for API routes
- sql`` template tag for raw SQL expressions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tsvector column and GIN index to schema</name>
  <files>packages/db/src/schema-pg.ts, packages/db/src/index.ts</files>
  <action>
1. Add customType for tsvector in schema-pg.ts:
   ```typescript
   import { customType } from "drizzle-orm/pg-core";
   import { SQL, sql } from "drizzle-orm";

   const tsvector = customType<{ data: string }>({
     dataType() {
       return "tsvector";
     },
   });
   ```

2. Add `search` generated column to mentalItems table:
   - Type: tsvector
   - Generated from: weighted combination of title (A) + content (B)
   - Use `generatedAlwaysAs` with SQL template

3. Add GIN index on the search column in table definition's second argument (the index function).

4. Export `sql` from packages/db/src/index.ts if not already exported (needed for queries).

**Pattern from RESEARCH.md:**
```typescript
search: tsvector("search")
  .generatedAlwaysAs(
    (): SQL =>
      sql`setweight(to_tsvector('english', ${mentalItems.title}), 'A') ||
          setweight(to_tsvector('english', ${mentalItems.content}), 'B')`,
  ),
```

Index in table definition:
```typescript
(t) => [
  index("idx_mental_items_search").using("gin", t.search),
]
```
  </action>
  <verify>pnpm --filter @mental/db build succeeds without errors</verify>
  <done>Schema has tsvector search column and GIN index defined.</done>
</task>

<task type="auto">
  <name>Task 2: Push schema to Neon and add search API endpoint</name>
  <files>packages/api/src/routes/items.ts</files>
  <action>
1. Push schema changes to Neon:
   ```bash
   cd packages/db && pnpm db:push
   ```

2. Add GET /search endpoint to items.ts route:
   - Query param: `q` (search query string)
   - If `q` empty or missing, return empty array
   - Use plainto_tsquery to convert user input to tsquery
   - Filter using `@@ ` match operator
   - Order by ts_rank descending
   - Limit to 50 results

**Pattern from RESEARCH.md:**
```typescript
.get(
  "/search",
  zValidator("query", z.object({ q: z.string().optional() })),
  async (c) => {
    const q = c.req.valid("query").q;
    if (!q || q.trim() === "") {
      return c.json([]);
    }

    const db = getDb();
    const searchQuery = sql`plainto_tsquery('english', ${q})`;

    const results = await db
      .select()
      .from(pg.mentalItems)
      .where(sql`${pg.mentalItems.search} @@ ${searchQuery}`)
      .orderBy(sql`ts_rank(${pg.mentalItems.search}, ${searchQuery}) DESC`)
      .limit(50);

    return c.json(results);
  }
)
```

Note: Import `sql` from drizzle-orm if not already imported.
  </action>
  <verify>
1. pnpm --filter @mental/api build succeeds
2. Start API: pnpm --filter @mental/api dev
3. Test search: curl "http://localhost:3000/items/search?q=test" returns JSON array
  </verify>
  <done>Schema pushed to Neon, search endpoint returns ranked results for query.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @mental/db build` succeeds
- [ ] `pnpm --filter @mental/api build` succeeds
- [ ] Schema pushed to Neon (db:push)
- [ ] GET /items/search?q=test returns results
- [ ] Results are ranked by relevance (title matches rank higher)
</verification>

<success_criteria>
- tsvector search column with weighted title/content
- GIN index on search column
- /items/search endpoint with plainto_tsquery
- Results ordered by ts_rank
</success_criteria>

<output>
After completion, create `.planning/phases/15-full-text-search/15-01-SUMMARY.md`
</output>
