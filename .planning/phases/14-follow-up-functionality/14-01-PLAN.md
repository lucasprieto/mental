---
phase: 14-follow-up-functionality
plan: 01
type: execute
depends_on: []
files_modified: [packages/db/src/schema-pg.ts, packages/api/src/routes/followups.ts, packages/api/src/index.ts, packages/shared/src/types.ts]
---

<objective>
Add follow-up data model and API endpoints.

Purpose: Enable thread-like updates on thoughts by creating the database schema and API layer for follow-ups.
Output: Working API endpoints for creating and retrieving follow-ups linked to items.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-dashboard-redesign/13-02-SUMMARY.md

**Key source files:**
@packages/db/src/schema-pg.ts
@packages/api/src/routes/items.ts
@packages/api/src/index.ts
@packages/shared/src/types.ts

**Existing patterns:**
- Drizzle ORM with pgTable for Postgres schema
- Hono with zValidator for API routes
- cuid2 for ID generation
- Type exports from @mental/shared
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add follow_ups schema and types</name>
  <files>packages/db/src/schema-pg.ts, packages/shared/src/types.ts, packages/db/src/index.ts</files>
  <action>
1. Add `followUps` table to schema-pg.ts:
   - id: text (cuid) primary key
   - itemId: text (foreign key to mental_items.id) NOT NULL
   - content: text NOT NULL (the follow-up text)
   - createdAt: timestamp NOT NULL

2. Export the new table and types from packages/db/src/index.ts

3. Add types to packages/shared/src/types.ts:
   ```typescript
   export interface FollowUp {
     id: string;
     itemId: string;
     content: string;
     createdAt: Date;
   }

   export interface CreateFollowUpInput {
     itemId: string;
     content: string;
   }
   ```

4. Run `pnpm --filter @mental/db build` to verify schema compiles
  </action>
  <verify>pnpm --filter @mental/db build succeeds. Types exported correctly.</verify>
  <done>follow_ups table schema defined, types exported from shared package.</done>
</task>

<task type="auto">
  <name>Task 2: Add follow-ups API routes</name>
  <files>packages/api/src/routes/followups.ts, packages/api/src/index.ts</files>
  <action>
1. Create packages/api/src/routes/followups.ts with Hono routes:
   - POST / - Create follow-up (body: { itemId, content })
   - GET /item/:itemId - Get all follow-ups for an item (sorted by createdAt ASC)

2. Follow existing patterns from items.ts:
   - Use zValidator for request validation
   - Use cuid2 for ID generation (import { createId } from "@paralleldrive/cuid2")
   - Return JSON responses with proper status codes
   - Handle item not found (404)

3. Mount routes in index.ts:
   - Import followupsApp from "./routes/followups.js"
   - Add `.route("/followups", followupsApp)`
   - Export FollowupsRoute type for client usage

4. Example route structure:
```typescript
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import { createId } from "@paralleldrive/cuid2";
import { getDb } from "../db.js";
import { followUps, mentalItems } from "@mental/db";
import { eq, asc } from "drizzle-orm";

const app = new Hono()
  .post(
    "/",
    zValidator("json", z.object({
      itemId: z.string(),
      content: z.string().min(1),
    })),
    async (c) => {
      const { itemId, content } = c.req.valid("json");
      const db = getDb();

      // Check item exists
      const item = await db.select().from(mentalItems).where(eq(mentalItems.id, itemId)).limit(1);
      if (item.length === 0) {
        return c.json({ error: "Item not found" }, 404);
      }

      const id = createId();
      const now = new Date();

      await db.insert(followUps).values({
        id,
        itemId,
        content,
        createdAt: now,
      });

      return c.json({ id, itemId, content, createdAt: now }, 201);
    }
  )
  .get("/item/:itemId", async (c) => {
    const itemId = c.req.param("itemId");
    const db = getDb();

    const results = await db
      .select()
      .from(followUps)
      .where(eq(followUps.itemId, itemId))
      .orderBy(asc(followUps.createdAt));

    return c.json(results);
  });

export default app;
```
  </action>
  <verify>pnpm --filter @mental/api build succeeds. Test with curl: POST /followups and GET /followups/item/:id</verify>
  <done>Follow-ups API routes working, mounted at /followups.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm --filter @mental/db build` succeeds
- [ ] `pnpm --filter @mental/api build` succeeds
- [ ] POST /followups creates follow-up linked to item
- [ ] GET /followups/item/:itemId returns follow-ups for item
- [ ] 404 returned when item doesn't exist
</verification>

<success_criteria>
- follow_ups schema defined with proper foreign key
- Types exported from @mental/shared
- API routes mounted and functional
- Follows existing patterns (Hono, zValidator, cuid2)
</success_criteria>

<output>
After completion, create `.planning/phases/14-follow-up-functionality/14-01-SUMMARY.md`
</output>
