---
phase: 07-backend-setup
plan: 02
type: execute
depends_on: ["07-01"]
files_modified: [packages/api/src/index.ts, packages/api/src/routes/items.ts, packages/api/src/routes/sessions.ts]
---

<objective>
Implement API routes for mental items and sessions CRUD operations.

Purpose: Provide complete API endpoints that MCP server and webapp can call for data operations.
Output: Full REST API with items and sessions routes, typed responses, validation.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-backend-setup/07-RESEARCH.md
@.planning/phases/07-backend-setup/07-01-SUMMARY.md

**Key files:**
@packages/db/src/schema-pg.ts
@packages/api/src/db.ts
@packages/api/src/index.ts
@packages/mcp-server/src/tools/capture.ts

**Tech stack from 07-01:** Hono, @neondatabase/serverless, drizzle-orm/neon-http, zod
**Established patterns:** Hono routes with zValidator, Drizzle queries, cuid2 for IDs

**CRITICAL from RESEARCH.md - Don't hand-roll:**
- Request validation → Use @hono/zod-validator with zod schemas
- API types → Export route types for hc client
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create items routes with full CRUD</name>
  <files>packages/api/src/routes/items.ts</files>
  <action>
Create packages/api/src/routes/items.ts with Hono routes:

1. GET / - List items with optional filters
   - Query params: status (open/resolved/all), limit (default 50), tags (comma-separated)
   - Returns array of items

2. GET /:id - Get single item by ID
   - Returns item or 404

3. POST / - Create new item
   - Body: { title, content, tags?, theme?, sessionId? }
   - Validate with zValidator and zod schema
   - Generate ID with cuid2
   - Set createdAt/updatedAt to now
   - Returns created item with 201

4. PUT /:id - Update item
   - Body: { title?, content?, tags?, theme?, status?, resolution? }
   - Update updatedAt
   - If status changes to 'resolved', set resolvedAt
   - Returns updated item or 404

5. DELETE /:id - Delete item
   - Returns 204 or 404

Use @paralleldrive/cuid2 for ID generation (add to api package.json if needed).
Use drizzle eq() for queries.

Export route type: export type ItemsRoute = typeof itemsRoute
  </action>
  <verify>TypeScript compiles without errors, all 5 endpoints defined</verify>
  <done>Items routes complete with validation, proper status codes, type exports</done>
</task>

<task type="auto">
  <name>Task 2: Create sessions routes</name>
  <files>packages/api/src/routes/sessions.ts</files>
  <action>
Create packages/api/src/routes/sessions.ts with Hono routes:

Note: Sessions in Mental are lightweight - they're just IDs that link items together.
The MCP server generates session IDs and passes them to items. The API just needs to:

1. GET /active - Get active session ID (stored in memory or simple state)
   - Returns { sessionId: string | null }

2. POST /start - Start a new session
   - Body: { name?: string }
   - Generate session ID with cuid2
   - Store as active session
   - Returns { sessionId: string, name?: string }

3. POST /end - End current session
   - Returns summary: { sessionId: string, itemCount: number }
   - Clears active session

For v1, use in-memory storage for active session (single instance, personal tool).
Later phases can persist sessions to database if needed.

Export route type: export type SessionsRoute = typeof sessionsRoute
  </action>
  <verify>TypeScript compiles, session routes handle start/end/active</verify>
  <done>Sessions routes complete with session ID management</done>
</task>

<task type="auto">
  <name>Task 3: Wire routes into main app and export types</name>
  <files>packages/api/src/index.ts</files>
  <action>
Update packages/api/src/index.ts:

1. Import routes:
   - import itemsRoute from './routes/items'
   - import sessionsRoute from './routes/sessions'

2. Mount routes:
   - app.route('/items', itemsRoute)
   - app.route('/sessions', sessionsRoute)

3. Export combined AppType for RPC client:
   ```typescript
   export type AppType = typeof app
   ```

4. Re-export route types for granular typing:
   ```typescript
   export type { ItemsRoute } from './routes/items'
   export type { SessionsRoute } from './routes/sessions'
   ```

The combined AppType allows clients to use:
```typescript
import { hc } from 'hono/client'
import type { AppType } from '@mental/api'
const client = hc<AppType>('http://localhost:3000')
```
  </action>
  <verify>pnpm --filter @mental/api build succeeds, types exported correctly</verify>
  <done>All routes mounted, types exported, API ready for deployment</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pnpm --filter @mental/api build succeeds
- [ ] All route files exist in packages/api/src/routes/
- [ ] AppType is exported from packages/api/src/index.ts
- [ ] No TypeScript errors
</verification>

<success_criteria>

- Items CRUD routes complete (GET list, GET single, POST, PUT, DELETE)
- Sessions routes complete (active, start, end)
- All routes use zValidator for request validation
- Types exported for Hono RPC client usage
- Phase 7 complete
</success_criteria>

<output>
After completion, create `.planning/phases/07-backend-setup/07-02-SUMMARY.md`
</output>
