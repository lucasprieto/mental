---
phase: 07-backend-setup
plan: 01
type: execute
depends_on: []
files_modified: [packages/api/package.json, packages/api/src/index.ts, packages/api/src/db.ts, packages/api/tsconfig.json, packages/db/src/schema-pg.ts, packages/db/src/index.ts, pnpm-workspace.yaml]
---

<objective>
Set up the @mental/api package with Hono framework and Neon Postgres database connection.

Purpose: Create the hosted API infrastructure that enables multi-computer access to Mental data.
Output: Working API package with Neon database connection, ready for route implementation.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-backend-setup/07-RESEARCH.md

**Key files:**
@packages/db/src/schema.ts
@packages/db/package.json
@package.json

**Tech stack available:** pnpm monorepo, TypeScript, Drizzle ORM
**Established patterns:** Package exports from db, schema types shared across packages

**Constraining decisions:**
- Phase 01-02: SQLite with Drizzle ORM, timestamps as integers (Unix epoch), tags as JSON string
- Research: Use Hono + Neon Postgres + Railway stack
- Research: Use @neondatabase/serverless with drizzle-orm/neon-http driver

**CRITICAL from RESEARCH.md - Don't hand-roll:**
- Database connection pooling → Use Neon's built-in pooler
- Request validation → Use @hono/zod-validator
- API client types → Use hono/client (hc) for type safety
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create @mental/api package with Hono</name>
  <files>packages/api/package.json, packages/api/tsconfig.json, pnpm-workspace.yaml</files>
  <action>
Create packages/api directory with:

1. package.json with:
   - name: "@mental/api"
   - dependencies: hono, @neondatabase/serverless, drizzle-orm, zod, @hono/zod-validator
   - devDependencies: typescript, @types/node
   - scripts: build (tsc), dev (tsx watch src/index.ts), start (node dist/index.js)

2. tsconfig.json extending root config with:
   - target: ES2022
   - module: NodeNext
   - moduleResolution: NodeNext
   - outDir: dist
   - rootDir: src

3. Verify pnpm-workspace.yaml includes packages/api (should already have packages/*)

Install dependencies with: pnpm install
  </action>
  <verify>pnpm --filter @mental/api build succeeds (even if empty index.ts)</verify>
  <done>@mental/api package exists with all dependencies installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Postgres schema variant for Drizzle</name>
  <files>packages/db/src/schema-pg.ts, packages/db/src/index.ts</files>
  <action>
Create packages/db/src/schema-pg.ts with the Postgres version of the schema:

1. Import from drizzle-orm/pg-core instead of sqlite-core
2. Use pgTable instead of sqliteTable
3. Keep same field names and types, but use Postgres equivalents:
   - text stays text
   - integer timestamps become timestamp (use { mode: 'date' } for Date objects)
   - All field constraints preserved

Schema should mirror packages/db/src/schema.ts exactly in structure but with Postgres types.

Export MentalItemRow and NewMentalItemRow types.

Update packages/db/src/index.ts to also export from schema-pg.ts:
- export * from './schema' (existing SQLite)
- export * as pg from './schema-pg' (new Postgres)

This allows both MCP server (SQLite) and API (Postgres) to share schema package.
  </action>
  <verify>pnpm --filter @mental/db build succeeds, exports both schemas</verify>
  <done>Postgres schema exists alongside SQLite schema, both exported from @mental/db</done>
</task>

<task type="auto">
  <name>Task 3: Create Hono app with Neon database connection</name>
  <files>packages/api/src/index.ts, packages/api/src/db.ts</files>
  <action>
Create packages/api/src/db.ts:

```typescript
import { neon } from '@neondatabase/serverless'
import { drizzle } from 'drizzle-orm/neon-http'
import { pg as schema } from '@mental/db'

const sql = neon(process.env.DATABASE_URL!)
export const db = drizzle(sql, { schema })
```

Create packages/api/src/index.ts with basic Hono app:

```typescript
import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { serve } from '@hono/node-server'

const app = new Hono()

// Middleware
app.use('*', logger())
app.use('*', cors())

// Health check
app.get('/health', (c) => c.json({ status: 'ok', timestamp: new Date().toISOString() }))

// Export type for RPC client
export type AppType = typeof app

// Start server
const port = parseInt(process.env.PORT || '3000')
console.log(`Starting server on port ${port}`)
serve({ fetch: app.fetch, port })
```

Add @hono/node-server to dependencies (needed for serve function).
  </action>
  <verify>pnpm --filter @mental/api build succeeds, API can start (will fail without DATABASE_URL but that's expected)</verify>
  <done>Hono app with Neon connection ready, health endpoint works</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pnpm --filter @mental/api build succeeds
- [ ] pnpm --filter @mental/db build succeeds
- [ ] packages/api/dist/index.js exists
- [ ] @mental/db exports both SQLite and Postgres schemas
</verification>

<success_criteria>

- @mental/api package created with Hono + Neon dependencies
- Postgres schema variant created in @mental/db
- Basic Hono app with health endpoint compiles
- Both packages build without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-backend-setup/07-01-SUMMARY.md`
</output>
