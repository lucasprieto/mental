---
phase: 04-session-lifecycle
plan: 01
type: execute
depends_on: ["03-02"]
files_modified: [packages/mcp-server/src/index.ts]
---

<objective>
Add resolve_thought tool to transition items from open to resolved.

Purpose: Complete the item lifecycle so users can mark thoughts as resolved with summaries.
Output: Working resolve_thought MCP tool.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-capture-engine/03-02-SUMMARY.md

**From Phase 3:**
- 4 tools: ping, capture_thought, list_thoughts, get_thought
- Database via getDatabase() from ./db.js
- mentalItems, desc, eq from @mental/db
- Tags as JSON string, dates as Date objects

**Schema fields for resolution:**
- status: "open" | "resolved"
- resolution: text (summary of how resolved)
- resolvedAt: timestamp (when resolved)

**Decisions:**
- [02-01]: console.error for all logging
- [03-02]: Re-export drizzle-orm utilities from @mental/db
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resolve_thought tool</name>
  <files>packages/mcp-server/src/index.ts</files>
  <action>
Add a resolve_thought tool that marks items as resolved:

```typescript
server.tool(
  "resolve_thought",
  "Mark a captured thought as resolved. Use when an item has been addressed, completed, or is no longer relevant. Provide a brief resolution summary.",
  {
    id: z.string().describe("The thought ID to resolve"),
    resolution: z.string().describe("Brief summary of how this was resolved or why it's no longer relevant")
  },
  async ({ id, resolution }) => {
    const db = getDatabase();
    const now = new Date();

    console.error(`[mental-mcp] Resolving thought: ${id}`);

    // First check if item exists and is open
    const items = await db.select()
      .from(mentalItems)
      .where(eq(mentalItems.id, id))
      .limit(1);

    if (items.length === 0) {
      return {
        content: [{
          type: "text",
          text: `Thought not found: ${id}`
        }]
      };
    }

    const item = items[0];

    if (item.status === "resolved") {
      return {
        content: [{
          type: "text",
          text: `Thought already resolved: "${item.title}"\nResolved at: ${item.resolvedAt?.toISOString()}\nResolution: ${item.resolution}`
        }]
      };
    }

    // Update to resolved
    await db.update(mentalItems)
      .set({
        status: "resolved",
        resolution,
        resolvedAt: now,
        updatedAt: now
      })
      .where(eq(mentalItems.id, id));

    console.error(`[mental-mcp] Resolved: "${item.title}"`);

    return {
      content: [{
        type: "text",
        text: `Resolved: "${item.title}"\nID: ${id}\nResolution: ${resolution}\nResolved at: ${now.toISOString()}`
      }]
    };
  }
);
```

CRITICAL:
- Use console.error for all logging (never console.log)
- Check item exists before updating
- Handle already-resolved case gracefully
  </action>
  <verify>pnpm --filter @mental/mcp-server build succeeds</verify>
  <done>resolve_thought tool transitions items from open to resolved with summary</done>
</task>

<task type="auto">
  <name>Task 2: Add reopen_thought tool</name>
  <files>packages/mcp-server/src/index.ts</files>
  <action>
Add a reopen_thought tool for reopening resolved items:

```typescript
server.tool(
  "reopen_thought",
  "Reopen a previously resolved thought. Use when an item needs further attention after being marked resolved.",
  {
    id: z.string().describe("The thought ID to reopen")
  },
  async ({ id }) => {
    const db = getDatabase();
    const now = new Date();

    console.error(`[mental-mcp] Reopening thought: ${id}`);

    const items = await db.select()
      .from(mentalItems)
      .where(eq(mentalItems.id, id))
      .limit(1);

    if (items.length === 0) {
      return {
        content: [{
          type: "text",
          text: `Thought not found: ${id}`
        }]
      };
    }

    const item = items[0];

    if (item.status === "open") {
      return {
        content: [{
          type: "text",
          text: `Thought is already open: "${item.title}"`
        }]
      };
    }

    await db.update(mentalItems)
      .set({
        status: "open",
        updatedAt: now
        // Note: Keep resolution and resolvedAt for history
      })
      .where(eq(mentalItems.id, id));

    console.error(`[mental-mcp] Reopened: "${item.title}"`);

    return {
      content: [{
        type: "text",
        text: `Reopened: "${item.title}"\nID: ${id}\nPrevious resolution: ${item.resolution || "none"}`
      }]
    };
  }
);
```

Note: Keep resolution and resolvedAt fields for history when reopening.
  </action>
  <verify>pnpm --filter @mental/mcp-server build succeeds</verify>
  <done>reopen_thought tool allows reopening resolved items</done>
</task>

<task type="auto">
  <name>Task 3: Verify lifecycle tools</name>
  <files>packages/mcp-server/src/index.ts</files>
  <action>
Final verification:

1. Build: pnpm --filter @mental/mcp-server build

2. Verify no console.log:
   grep -r "console.log" packages/mcp-server/src/ should return nothing

3. Tool count should now be 6:
   - ping
   - capture_thought
   - list_thoughts
   - get_thought
   - resolve_thought
   - reopen_thought
  </action>
  <verify>Build succeeds, no console.log, 6 tools available</verify>
  <done>Lifecycle tools complete: resolve and reopen working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pnpm -r build succeeds
- [ ] resolve_thought marks items as resolved with summary
- [ ] reopen_thought reopens resolved items
- [ ] No console.log statements
- [ ] 6 tools registered
</verification>

<success_criteria>
- resolve_thought transitions open → resolved with summary
- reopen_thought transitions resolved → open
- Both tools handle edge cases (not found, wrong status)
- All tools use console.error for logging
</success_criteria>

<output>
After completion, create `.planning/phases/04-session-lifecycle/04-01-SUMMARY.md`
</output>
